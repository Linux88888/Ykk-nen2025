name: Update Match Data and Generate Report

on:
  schedule:
    # Aja joka tunti (voit säätää tätä tarvittaessa)
    - cron: '0 * * * *'
  workflow_dispatch: # Mahdollistaa manuaalisen ajon

jobs:
  scrape_and_report:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11' # Käytä ajantasaista Python-versiota

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install beautifulsoup4 selenium webdriver-manager requests

      # Asenna Google Chrome (tarvitaan Seleniumille headless-tilassa)
      - name: Setup Chrome
        uses: browser-actions/setup-chrome@v1.6.0 # Käytä ajan tasalla olevaa actionia
        with:
          chrome-version: stable # Käytä vakaata versiota

      - name: Run audience scraper
        run: |
          echo "--- Running Python script ---"
          python audience_scraper.py
          echo "--- Python script finished ---"

      - name: Generate Markdown Report
        id: generate_markdown
        run: |
          echo "--- Generating Markdown report ---"
          python - <<EOF
          import json
          import datetime
          import os

          INPUT_JSON = "match_data.json"
          OUTPUT_MD = "PelatutOttelut.md"
          MAX_REPORT_ROWS = 50 # Rajoita raportin rivien määrää tarvittaessa

          try:
              with open(INPUT_JSON, 'r', encoding='utf-8') as f:
                  all_data = json.load(f)
          except (FileNotFoundError, json.JSONDecodeError) as e:
              print(f"Error reading or parsing {INPUT_JSON}: {e}")
              all_data = []

          # Suodata vain onnistuneesti haetut ja päättyneet ottelut, joilla on joukkueet
          finished_matches = [
              match for match in all_data
              if isinstance(match, dict) and \
                 match.get('status') == 'success_finished' and \
                 match.get('team_home') and \
                 match.get('team_away') and \
                 match.get('score')
          ]

          # Järjestä uusimman scrape_timestampin mukaan (tai match_id:n jos timestamp puuttuu)
          # Yritetään olettaa, että korkeampi ID on uudempi, jos timestamp puuttuu
          finished_matches.sort(key=lambda x: x.get('match_id', 0), reverse=True)

          # Rajoita tulostettavien otteluiden määrää
          limited_matches = finished_matches[:MAX_REPORT_ROWS]

          utc_now = datetime.datetime.now(datetime.timezone.utc)
          markdown_content = f"# Pelatut Ottelut\n\nPäivitetty: {utc_now.strftime('%Y-%m-%d %H:%M:%S %Z')}\n\n"

          if not limited_matches:
              markdown_content += "Ei pelattuja otteluita datassa.\n"
          else:
              # -- LAAJENNETTU TAULUKKO --
              header = "| Päivämäärä | Aika | Kotijoukkue | Tulos | Vierasjoukkue | Yleisö | Paikka | Sää | Ottelu ID |\n"
              separator = "|:-----------|:-----|:------------|:------|:--------------|:-------|:-------|:----|:----------|\n"
              markdown_content += header + separator
              stats_sections = "" # Kerätään tilasto-osiot tänne

              for match in limited_matches:
                  # Parsi päivämäärä ja aika
                  raw_dt = match.get('match_datetime_raw', '')
                  date_part = 'N/A'
                  time_part = 'N/A'
                  if raw_dt and '|' in raw_dt:
                      parts = raw_dt.split('|')
                      if len(parts) > 1:
                          time_part = parts[0].strip()
                          # Muotoile päivämäärä hieman paremmin (esim. poista piste lopusta)
                          date_part = parts[1].strip().replace('.', '. ').rstrip('. ')
                  elif raw_dt: # Käsittele tapaukset ilman '|'
                      if ':' in raw_dt: time_part = raw_dt.strip()
                      else: date_part = raw_dt.strip().replace('.', '. ').rstrip('. ')

                  # Hae muut kentät, käytä 'N/A' jos puuttuu
                  venue = match.get('venue') or 'N/A'
                  weather = match.get('weather') or 'N/A'
                  audience = match.get('audience') or 'N/A'
                  # Käytä sivulta löytyvää ID:tä, jos saatavilla, muuten URL:n ID:tä
                  match_id_display = match.get('match_id_from_page') or match.get('match_id', 'N/A')
                  home_team = match.get('team_home') or 'N/A'
                  away_team = match.get('team_away') or 'N/A'
                  score = match.get('score') or 'N/A'

                  # Lisää rivi päätaulukkoon
                  table_row = f"| {str(date_part)} | {str(time_part)} | {str(home_team)} | {str(score)} | {str(away_team)} | {str(audience)} | {str(venue)} | {str(weather)} | {str(match_id_display)} |\n"
                  markdown_content += table_row

                  # -- TILASTO-OSIO --
                  stats = match.get('stats', {})
                  if stats:
                      # Lisää otsikko tilastoille (linkitä otteluun jos mahdollista)
                      stats_sections += f"\n## Tilastot: {home_team} vs {away_team} ({date_part} - ID: {match_id_display})\n\n"
                      stats_sections += "| Tilasto                 | Koti | Vieras |\n"
                      stats_sections += "|:------------------------|:-----|:-------|\n"
                      # Järjestä tilastot aakkosjärjestykseen avaimen mukaan
                      for key, values in sorted(stats.items()):
                          # Siistimpi nimi tilastolle
                          stat_name = key.replace('_', ' ').capitalize()
                          home_val = values.get('home', 'N/A')
                          away_val = values.get('away', 'N/A')
                          # Määritä sarakkeiden leveydet (säädä tarvittaessa)
                          stats_sections += f"| {stat_name:<23} | {str(home_val):<4} | {str(away_val):<6} |\n"
                      stats_sections += "\n" # Lisää tyhjä rivi ennen seuraavaa ottelua
                  else:
                      stats_sections += f"\n## Tilastot: {home_team} vs {away_team} ({date_part} - ID: {match_id_display})\n\n"
                      stats_sections += "*Ei tilastotietoja saatavilla.*\n\n"

              # Lisää kerätyt tilasto-osiot päätaulukon jälkeen
              markdown_content += "\n---\n" # Erotinviiva taulukon ja tilastojen väliin
              markdown_content += stats_sections


          # Tallenna Markdown-tiedosto
          try:
              with open(OUTPUT_MD, 'w', encoding='utf-8') as f:
                  f.write(markdown_content)
              print(f"Markdown report generated successfully: {OUTPUT_MD}")
              # Aseta output actionille, jotta commit-vaihe löytää sen
              print(f"::set-output name=md_file::{OUTPUT_MD}")
          except Exception as e:
              print(f"Error writing Markdown file: {e}")
              # Aseta tyhjä output jos tallennus epäonnistui
              print(f"::set-output name=md_file::")

          EOF
          echo "--- Markdown generation finished ---"

      - name: Commit and push changes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MD_FILE: ${{ steps.generate_markdown.outputs.md_file }}
        run: |
          echo "Checking if MD file was generated: $MD_FILE"
          if [ -z "$MD_FILE" ]; then
            echo "Markdown file name is empty, skipping commit."
            exit 0
          fi

          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          # Lisää kaikki muuttuneet tiedostot (JSON, MD, log, last_id)
          git add match_data.json PelatutOttelut.md match_scraper.log last_match_id.txt scrape_cache/*_err.png || echo "No error images to add"
          # Tarkista onko muutoksia ennen committia
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Päivitä otteludata ja raportti"
            # Yritä työntää muutokset, salli virhe jos remote on muuttunut
            git push || echo "Push failed, possibly due to concurrent updates."
          fi
